---
- name: Configure XOS Management bond (bond-mgmt) + hostname reconciliation
  hosts: all
  become: true
  gather_facts: true

  vars:
    # ---- Bond/Interfaces ----
    bond_name: "bond-mgmt"
    slave1_con: "bond-mgmt-interface-1"
    slave2_con: "bond-mgmt-interface-2"
    slave1_if: "eno1"
    slave2_if: "eno2"

    gw: "10.11.15.254"
    dns: "10.15.10.1"
    dns_search: "dsc.local"

    bond_options: "mode=active-backup,primary=eno1,miimon=100,updelay=100"

  tasks:
    # --------------------------
    # Capture current IP before any changes (check bond first, then eno1)
    # --------------------------
    - name: Check if bond already exists and has IP
      command: "nmcli -g IP4.ADDRESS dev show {{ bond_name }}"
      register: bond_ip_raw_initial
      changed_when: false
      failed_when: false

    - name: Extract bond IP address if it exists
      set_fact:
        bond_ip_initial: >-
          {{
            (bond_ip_raw_initial.stdout_lines | default([]) | select('match','.+/.+') | list | first)
            | default('')
          }}
        captured_ip_addr: ""

    - name: Read IPv4 address from eno1 (only if bond doesn't have IP)
      command: "nmcli -g IP4.ADDRESS dev show {{ slave1_if }}"
      register: eno1_ip_raw_initial
      changed_when: false
      failed_when: false
      when: bond_ip_initial == ""

    - name: Extract IP address from eno1 (CIDR format)
      set_fact:
        captured_ip_addr: >-
          {{
            (eno1_ip_raw_initial.stdout_lines | default([]) | select('match','.+/.+') | list | first)
            | default('')
          }}
      when: bond_ip_initial == ""

    - name: Debug IP capture results
      debug:
        msg:
          - "Bond IP (if exists): {{ bond_ip_initial }}"
          - "Captured IP from {{ slave1_if }}: {{ captured_ip_addr | default('N/A') }}"
          - "Will use: {{ bond_ip_initial if bond_ip_initial != '' else captured_ip_addr | default('NONE') }}"

    - name: Fail if no IP address found (neither bond nor eno1)
      fail:
        msg: >-
          No IPv4 address found. Bond {{ bond_name }} IP={{ bond_ip_initial }},
          {{ slave1_if }} IP={{ captured_ip_addr | default('N/A') }}.
          Cannot proceed safely.
      when: (bond_ip_initial == "") and (captured_ip_addr | default('') == "")

    # --------------------------
    # Hostname reconciliation
    # --------------------------
    - name: Get runtime hostname
      command: hostname
      register: runtime_hostname
      changed_when: false

    - name: Read /etc/hostname
      command: cat /etc/hostname
      register: file_hostname
      changed_when: false
      failed_when: false

    - name: Debug hostname state
      debug:
        msg:
          - "Runtime hostname : {{ runtime_hostname.stdout | trim }}"
          - "/etc/hostname    : {{ file_hostname.stdout | default('') | trim }}"
          - "Hostname match   : {{ (runtime_hostname.stdout | trim) == (file_hostname.stdout | default('') | trim) }}"

    - name: Update /etc/hostname to match runtime hostname if different
      copy:
        content: "{{ runtime_hostname.stdout | trim }}\n"
        dest: /etc/hostname
        owner: root
        group: root
        mode: '0644'
      when: runtime_hostname.stdout | trim != file_hostname.stdout | default('') | trim

    # --------------------------
    # Preconditions
    # --------------------------
    - name: Ensure nmcli exists
      command: nmcli -v
      register: nmcli_ver
      changed_when: false

    - name: Get NetworkManager devices
      command: "nmcli -t -f DEVICE dev status"
      register: nm_devs
      changed_when: false

    - name: Debug static configuration variables
      debug:
        msg:
          bond_name: "{{ bond_name }}"
          slave1_if: "{{ slave1_if }}"
          slave2_if: "{{ slave2_if }}"
          slave1_con: "{{ slave1_con }}"
          slave2_con: "{{ slave2_con }}"
          gateway: "{{ gw }}"
          dns: "{{ dns }}"
          dns_search: "{{ dns_search }}"
          bond_options: "{{ bond_options }}"

    - name: Debug detected NetworkManager devices
      debug:
        var: nm_devs.stdout_lines

    - name: Fail if eno1 or eno2 are missing
      fail:
        msg: "Required interfaces not found. Need {{ slave1_if }} and {{ slave2_if }}. Found: {{ nm_devs.stdout_lines }}"
      when: >
        (slave1_if not in nm_devs.stdout_lines) or
        (slave2_if not in nm_devs.stdout_lines)

    # --------------------------
    # Debug-only network_info (eno1)
    # --------------------------
    - name: Debug network info (device show for eno1)
      command: "nmcli dev show {{ slave1_if }}"
      register: network_info
      changed_when: false

    - name: Print network_info for debugging
      debug:
        var: network_info.stdout_lines

    # --------------------------
    # Determine final IP address to use (bond takes precedence)
    # --------------------------
    - name: Set final IP address (prefer bond IP if it exists, otherwise use captured eno1 IP)
      set_fact:
        ip_addr: "{{ bond_ip_initial if bond_ip_initial != '' else (captured_ip_addr | default('')) }}"

    - name: Debug final IP selection
      debug:
        msg:
          - "Bond IP (initial check): {{ bond_ip_initial }}"
          - "Captured IP from eno1: {{ captured_ip_addr | default('N/A') }}"
          - "Final IP for bond-mgmt: {{ ip_addr }}"

    # --------------------------
    # Ensure bond + slaves exist
    # --------------------------
    - name: Get existing NM connection names
      command: "nmcli -t -f NAME con show"
      register: nm_con_names
      changed_when: false

    - name: Set existence flags
      set_fact:
        bond_exists: "{{ bond_name in nm_con_names.stdout_lines }}"
        slave1_exists: "{{ slave1_con in nm_con_names.stdout_lines }}"
        slave2_exists: "{{ slave2_con in nm_con_names.stdout_lines }}"

    - name: Debug NM connection existence
      debug:
        msg:
          bond_exists: "{{ bond_exists }}"
          slave1_exists: "{{ slave1_exists }}"
          slave2_exists: "{{ slave2_exists }}"

    - name: Create bond connection if missing
      command: >
        nmcli con add type bond
        con-name {{ bond_name }}
        ifname {{ bond_name }}
        mode active-backup
      when: not bond_exists

    - name: Create slave1 connection if missing (eno1 -> bond-mgmt-interface-1)
      command: >
        nmcli con add type ethernet
        con-name {{ slave1_con }}
        ifname {{ slave1_if }}
        slave-type bond
        master {{ bond_name }}
      when: not slave1_exists

    - name: Create slave2 connection if missing (eno2 -> bond-mgmt-interface-2)
      command: >
        nmcli con add type ethernet
        con-name {{ slave2_con }}
        ifname {{ slave2_if }}
        slave-type bond
        master {{ bond_name }}
      when: not slave2_exists

    - name: Debug connection types (bond + slaves)
      command: "nmcli -t -f NAME,TYPE,DEVICE con show"
      register: con_show_all
      changed_when: false

    - name: Print connection types (filtered)
      debug:
        msg: "{{ con_show_all.stdout_lines | select('search', '^(bond-mgmt|bond-mgmt-interface)') | list }}"

    # --------------------------
    # Enforce desired config (idempotent)
    # --------------------------
    - name: Ensure slave connections are enslaved to the bond (idempotent)
      command: >
        nmcli con mod {{ item.con }}
        connection.master {{ bond_name }}
        connection.slave-type bond
        connection.autoconnect yes
      loop:
        - { con: "{{ slave1_con }}", if: "{{ slave1_if }}" }
        - { con: "{{ slave2_con }}", if: "{{ slave2_if }}" }

    - name: Remove any IPv4/IPv6 settings from slaves (safe if none exist)
      command: >
        nmcli con mod {{ item }}
        -ipv4.addresses -ipv4.gateway -ipv4.dns -ipv4.dns-search -ipv4.method
        -ipv6.addresses -ipv6.gateway -ipv6.dns -ipv6.dns-search -ipv6.method
      loop:
        - "{{ slave1_con }}"
        - "{{ slave2_con }}"
      register: strip_ip_from_slaves
      failed_when: false

    - name: Configure bond options + IPv4 on bond
      command: >
        nmcli con mod {{ bond_name }}
        bond.options "{{ bond_options }}"
        ipv4.addresses "{{ ip_addr }}"
        ipv4.gateway "{{ gw }}"
        ipv4.dns "{{ dns }}"
        ipv4.dns-search "{{ dns_search }}"
        ipv4.method manual
        ipv6.method disabled
        connection.autoconnect yes

    - name: Reload NM connections
      command: nmcli con reload
      changed_when: false

    - name: Debug final bond configuration intent
      debug:
        msg:
          - "Bond name  : {{ bond_name }}"
          - "Bond IP    : {{ ip_addr }}"
          - "Gateway    : {{ gw }}"
          - "DNS        : {{ dns }}"
          - "DNS search : {{ dns_search }}"
          - "Slaves     : {{ slave1_if }}, {{ slave2_if }}"

    - name: Bring up bond connection
      command: "nmcli con up {{ bond_name }}"

    - name: Wait for bond to obtain IPv4 address
      command: nmcli -g IP4.ADDRESS dev show {{ bond_name }}
      register: bond_ip_check
      retries: 8
      delay: 5
      until: bond_ip_check.stdout is search('.+/.+')
      failed_when: false

    - name: Debug bond IP after bring up
      debug:
        msg: "Bond IP: {{ bond_ip_check.stdout | default('') }}"

    - name: Refresh NM connection list
      command: "nmcli -t -f NAME con show"
      register: nm_con_names_post
      changed_when: false

    - name: Debug connections after bond bring-up
      debug:
        var: nm_con_names_post.stdout_lines

    # --------------------------
    # Cleanup orphaned connections
    # --------------------------
    - name: Get all NetworkManager connections
      command: "nmcli -t -f NAME con show"
      register: all_connections
      changed_when: false

    - name: Debug all connections before cleanup
      debug:
        var: all_connections.stdout_lines

    - name: Build list of orphaned connection names to check (with and without "System " prefix)
      set_fact:
        orphaned_connection_names:
          - "Wired connection 1"
          - "Wired connection 2"
          - "Ethernet connection 1"
          - "eth0"
          - "System eth0"
          - "eno1"
          - "System eno1"
          - "eno2"
          - "System eno2"
          - "eno3"
          - "System eno3"
          - "eno4"
          - "System eno4"
          - "ens3f0"
          - "System ens3f0"
          - "ens3f1"
          - "System ens3f1"
          - "ens4f0"
          - "System ens4f0"
          - "ens4f1"
          - "System ens4f1"

    - name: Find orphaned connections that actually exist
      set_fact:
        connections_to_delete: "{{ orphaned_connection_names | select('in', all_connections.stdout_lines) | list }}"

    - name: Debug connections to delete
      debug:
        msg: "Found {{ connections_to_delete | length }} orphaned connections to delete: {{ connections_to_delete }}"

    - name: Bring down orphaned connections before deletion (if active)
      command: "nmcli con down '{{ item }}'"
      loop: "{{ connections_to_delete }}"
      failed_when: false
      changed_when: false

    - name: Remove orphaned/stale connections
      command: "nmcli con delete '{{ item }}'"
      loop: "{{ connections_to_delete }}"
      failed_when: false
      register: delete_orphans

    - name: Debug deletion results
      debug:
        msg:
          - "Attempted to delete {{ connections_to_delete | length }} connections"
          - "Connections: {{ connections_to_delete }}"
          - "Results: {{ delete_orphans.results | default([]) | map(attribute='stdout', default='') | list }}"
      when: connections_to_delete | length > 0